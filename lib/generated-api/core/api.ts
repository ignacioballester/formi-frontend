/* tslint:disable */
/* eslint-disable */
/**
 * Formi API
 * API for managing organizations, projects, and related resources
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateModuleInput
 */
export interface CreateModuleInput {
    /**
     * Name of the module
     * @type {string}
     * @memberof CreateModuleInput
     */
    'name': string;
    /**
     * ID of the repository containing the module
     * @type {number}
     * @memberof CreateModuleInput
     */
    'repository_id': number;
    /**
     * Working directory for the module
     * @type {string}
     * @memberof CreateModuleInput
     */
    'working_directory': string;
    /**
     * ID of the project this module belongs to
     * @type {number}
     * @memberof CreateModuleInput
     */
    'project_id'?: number;
    /**
     * ID of the organization this module belongs to
     * @type {number}
     * @memberof CreateModuleInput
     */
    'organization_id': number;
    /**
     * 
     * @type {GitReference}
     * @memberof CreateModuleInput
     */
    'git_reference': GitReference;
}
/**
 * 
 * @export
 * @interface CreateOrganizationInput
 */
export interface CreateOrganizationInput {
    /**
     * Name of the organization
     * @type {string}
     * @memberof CreateOrganizationInput
     */
    'name': string;
    /**
     * Description of the organization
     * @type {string}
     * @memberof CreateOrganizationInput
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CreateProjectInput
 */
export interface CreateProjectInput {
    /**
     * Name of the project
     * @type {string}
     * @memberof CreateProjectInput
     */
    'name': string;
    /**
     * ID of the organization this project belongs to
     * @type {number}
     * @memberof CreateProjectInput
     */
    'organization_id': number;
}
/**
 * 
 * @export
 * @interface CreateRepositoryInput
 */
export interface CreateRepositoryInput {
    /**
     * Name of the repository
     * @type {string}
     * @memberof CreateRepositoryInput
     */
    'name': string;
    /**
     * URL of the repository
     * @type {string}
     * @memberof CreateRepositoryInput
     */
    'url': string;
    /**
     * ID of the project this repository belongs to
     * @type {number}
     * @memberof CreateRepositoryInput
     */
    'project_id'?: number;
    /**
     * ID of the organization this repository belongs to
     * @type {number}
     * @memberof CreateRepositoryInput
     */
    'organization_id': number;
    /**
     * 
     * @type {SecretIdentifier}
     * @memberof CreateRepositoryInput
     */
    'secret': SecretIdentifier;
}
/**
 * 
 * @export
 * @interface DeployModuleInput
 */
export interface DeployModuleInput {
    /**
     * ID of the module to deploy
     * @type {number}
     * @memberof DeployModuleInput
     */
    'module_id': number;
    /**
     * ID of the project to deploy to
     * @type {number}
     * @memberof DeployModuleInput
     */
    'project_id': number;
    /**
     * 
     * @type {DeploymentInputs}
     * @memberof DeployModuleInput
     */
    'inputs': DeploymentInputs;
}
/**
 * 
 * @export
 * @interface Deployment
 */
export interface Deployment {
    /**
     * Unique identifier for the deployment
     * @type {number}
     * @memberof Deployment
     */
    'id': number;
    /**
     * Version number of the deployment
     * @type {number}
     * @memberof Deployment
     */
    'version': number;
    /**
     * ID of the project this deployment belongs to
     * @type {number}
     * @memberof Deployment
     */
    'project_id': number;
    /**
     * ID of the module being deployed
     * @type {number}
     * @memberof Deployment
     */
    'module_id': number;
    /**
     * 
     * @type {DeploymentInputs}
     * @memberof Deployment
     */
    'inputs': DeploymentInputs;
    /**
     * 
     * @type {DeploymentStatus}
     * @memberof Deployment
     */
    'status': DeploymentStatus;
    /**
     * 
     * @type {DeploymentStatusDetails}
     * @memberof Deployment
     */
    'status_details': DeploymentStatusDetails;
}


/**
 * 
 * @export
 * @interface DeploymentInputs
 */
export interface DeploymentInputs {
    /**
     * Terraform variables
     * @type {object}
     * @memberof DeploymentInputs
     */
    'tf_vars': object;
    /**
     * 
     * @type {Array<object>}
     * @memberof DeploymentInputs
     */
    'secrets'?: Array<object>;
    /**
     * 
     * @type {Array<DeploymentVariableInput>}
     * @memberof DeploymentInputs
     */
    'deployment_variable_inputs'?: Array<DeploymentVariableInput>;
}
/**
 * Current status of the deployment
 * @export
 * @enum {string}
 */

export const DeploymentStatus = {
    Creating: 'creating',
    Active: 'active',
    Inactive: 'inactive',
    Updating: 'updating',
    Destroying: 'destroying',
    Failed: 'failed'
} as const;

export type DeploymentStatus = typeof DeploymentStatus[keyof typeof DeploymentStatus];


/**
 * 
 * @export
 * @interface DeploymentStatusDetails
 */
export interface DeploymentStatusDetails {
    /**
     * ID of the last run
     * @type {number}
     * @memberof DeploymentStatusDetails
     */
    'last_run_id': number;
    /**
     * Error message if the deployment failed
     * @type {string}
     * @memberof DeploymentStatusDetails
     */
    'error_message': string;
}
/**
 * 
 * @export
 * @interface DeploymentVariable
 */
export interface DeploymentVariable {
    /**
     * Name of the deployment variable
     * @type {string}
     * @memberof DeploymentVariable
     */
    'name': string;
    /**
     * Default value for the variable
     * @type {object}
     * @memberof DeploymentVariable
     */
    'default'?: object;
    /**
     * Description of the variable
     * @type {string}
     * @memberof DeploymentVariable
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentVariableInput
 */
export interface DeploymentVariableInput {
    /**
     * Name of the variable
     * @type {string}
     * @memberof DeploymentVariableInput
     */
    'name': string;
    /**
     * Value of the variable
     * @type {string}
     * @memberof DeploymentVariableInput
     */
    'input': string;
}
/**
 * 
 * @export
 * @interface DeploymentsIdDelete200Response
 */
export interface DeploymentsIdDelete200Response {
    /**
     * 
     * @type {Run}
     * @memberof DeploymentsIdDelete200Response
     */
    'run'?: Run;
}
/**
 * 
 * @export
 * @interface DeploymentsPost201Response
 */
export interface DeploymentsPost201Response {
    /**
     * 
     * @type {Deployment}
     * @memberof DeploymentsPost201Response
     */
    'deployment'?: Deployment;
    /**
     * 
     * @type {Run}
     * @memberof DeploymentsPost201Response
     */
    'run'?: Run;
}
/**
 * 
 * @export
 * @interface EnvironmentVariable
 */
export interface EnvironmentVariable {
    /**
     * Name of the environment variable
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'name': string;
    /**
     * Value of the environment variable
     * @type {string}
     * @memberof EnvironmentVariable
     */
    'input': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Error message
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ExternalModule
 */
export interface ExternalModule {
    /**
     * Name of the external module
     * @type {string}
     * @memberof ExternalModule
     */
    'module_name': string;
    /**
     * Name of the variable referencing the module
     * @type {string}
     * @memberof ExternalModule
     */
    'variable_name': string;
}
/**
 * 
 * @export
 * @interface GitReference
 */
export interface GitReference {
    /**
     * Git tag reference
     * @type {string}
     * @memberof GitReference
     */
    'tag'?: string;
    /**
     * Git commit hash
     * @type {string}
     * @memberof GitReference
     */
    'commit'?: string;
    /**
     * Git branch name
     * @type {string}
     * @memberof GitReference
     */
    'branch'?: string;
}
/**
 * 
 * @export
 * @interface Module
 */
export interface Module {
    /**
     * Unique identifier for the module
     * @type {number}
     * @memberof Module
     */
    'id': number;
    /**
     * Name of the module
     * @type {string}
     * @memberof Module
     */
    'name': string;
    /**
     * ID of the repository containing the module
     * @type {number}
     * @memberof Module
     */
    'repository_id': number;
    /**
     * ID of the project this module belongs to
     * @type {number}
     * @memberof Module
     */
    'project_id'?: number;
    /**
     * ID of the organization this module belongs to
     * @type {number}
     * @memberof Module
     */
    'organization_id': number;
    /**
     * Working directory for the module
     * @type {string}
     * @memberof Module
     */
    'working_directory': string;
    /**
     * 
     * @type {GitReference}
     * @memberof Module
     */
    'git_reference': GitReference;
    /**
     * 
     * @type {TerraformProperties}
     * @memberof Module
     */
    'terraform_properties': TerraformProperties;
    /**
     * 
     * @type {ModuleConfig}
     * @memberof Module
     */
    'module_config': ModuleConfig;
    /**
     * 
     * @type {ModuleStatus}
     * @memberof Module
     */
    'status': ModuleStatus;
}
/**
 * 
 * @export
 * @interface ModuleConfig
 */
export interface ModuleConfig {
    /**
     * Path to the module configuration file
     * @type {string}
     * @memberof ModuleConfig
     */
    'config_file_path'?: string;
    /**
     * Variable configurations
     * @type {{ [key: string]: VariableConfiguration; }}
     * @memberof ModuleConfig
     */
    'variables'?: { [key: string]: VariableConfiguration; };
    /**
     * Review requirements
     * @type {Array<ReviewRequirement>}
     * @memberof ModuleConfig
     */
    'review_required'?: Array<ReviewRequirement>;
    /**
     * Credential configurations
     * @type {Array<ModuleCredentialConfiguration>}
     * @memberof ModuleConfig
     */
    'credentials'?: Array<ModuleCredentialConfiguration>;
    /**
     * Environment variable configurations
     * @type {Array<EnvironmentVariable>}
     * @memberof ModuleConfig
     */
    'environment_variables'?: Array<EnvironmentVariable>;
    /**
     * Deployment variable configurations
     * @type {Array<DeploymentVariable>}
     * @memberof ModuleConfig
     */
    'deployment_variables'?: Array<DeploymentVariable>;
    /**
     * External module configurations
     * @type {Array<ExternalModule>}
     * @memberof ModuleConfig
     */
    'external_modules'?: Array<ExternalModule>;
}
/**
 * 
 * @export
 * @interface ModuleCredentialConfiguration
 */
export interface ModuleCredentialConfiguration {
    /**
     * Type of credential
     * @type {string}
     * @memberof ModuleCredentialConfiguration
     */
    'type': string;
    /**
     * Available credential options
     * @type {Array<SecretIdentifier>}
     * @memberof ModuleCredentialConfiguration
     */
    'options'?: Array<SecretIdentifier>;
    /**
     * Whether project credentials are allowed
     * @type {boolean}
     * @memberof ModuleCredentialConfiguration
     */
    'project_credentials_allowed'?: boolean;
}
/**
 * 
 * @export
 * @interface ModuleStatus
 */
export interface ModuleStatus {
    /**
     * Whether the module configuration is valid
     * @type {boolean}
     * @memberof ModuleStatus
     */
    'configuration_valid'?: boolean;
    /**
     * Error message if configuration is invalid
     * @type {string}
     * @memberof ModuleStatus
     */
    'configuration_error'?: string;
    /**
     * Whether the Terraform configuration is valid
     * @type {boolean}
     * @memberof ModuleStatus
     */
    'terraform_valid'?: boolean;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * Unique identifier for the organization
     * @type {number}
     * @memberof Organization
     */
    'id': number;
    /**
     * Name of the organization
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * Description of the organization
     * @type {string}
     * @memberof Organization
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * Unique identifier for the project
     * @type {number}
     * @memberof Project
     */
    'id': number;
    /**
     * Name of the project
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * ID of the organization this project belongs to
     * @type {number}
     * @memberof Project
     */
    'organization_id': number;
}
/**
 * 
 * @export
 * @interface Repository
 */
export interface Repository {
    /**
     * Unique identifier for the repository
     * @type {number}
     * @memberof Repository
     */
    'id': number;
    /**
     * Name of the repository
     * @type {string}
     * @memberof Repository
     */
    'name': string;
    /**
     * URL of the repository
     * @type {string}
     * @memberof Repository
     */
    'url': string;
    /**
     * ID of the project this repository belongs to
     * @type {number}
     * @memberof Repository
     */
    'project_id'?: number;
    /**
     * ID of the organization this repository belongs to
     * @type {number}
     * @memberof Repository
     */
    'organization_id': number;
    /**
     * 
     * @type {SecretIdentifier}
     * @memberof Repository
     */
    'secret': SecretIdentifier;
    /**
     * 
     * @type {RepositoryStatus}
     * @memberof Repository
     */
    'status': RepositoryStatus;
}
/**
 * 
 * @export
 * @interface RepositoryResponse
 */
export interface RepositoryResponse {
    /**
     * 
     * @type {Repository}
     * @memberof RepositoryResponse
     */
    'repository'?: Repository;
    /**
     * 
     * @type {Array<GitReference>}
     * @memberof RepositoryResponse
     */
    'references'?: Array<GitReference>;
}
/**
 * 
 * @export
 * @interface RepositoryStatus
 */
export interface RepositoryStatus {
    /**
     * Whether the repository connection is successful
     * @type {boolean}
     * @memberof RepositoryStatus
     */
    'connection_successful': boolean;
}
/**
 * 
 * @export
 * @interface ReviewRequirement
 */
export interface ReviewRequirement {
    /**
     * Condition when review is required
     * @type {string}
     * @memberof ReviewRequirement
     */
    'when': string;
    /**
     * List of reviewers required
     * @type {Array<string>}
     * @memberof ReviewRequirement
     */
    'by': Array<string>;
}
/**
 * Details about the deployment run
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * Unique identifier for the run
     * @type {number}
     * @memberof Run
     */
    'id': number;
    /**
     * Status of the run
     * @type {string}
     * @memberof Run
     */
    'status': string;
    /**
     * Error message if the run failed
     * @type {string}
     * @memberof Run
     */
    'error_message': string;
}
/**
 * 
 * @export
 * @interface SecretIdentifier
 */
export interface SecretIdentifier {
    /**
     * Name of the secret
     * @type {string}
     * @memberof SecretIdentifier
     */
    'name': string;
    /**
     * ID of the organization that owns the secret
     * @type {number}
     * @memberof SecretIdentifier
     */
    'organization_id': number;
    /**
     * ID of the project that owns the secret (optional)
     * @type {number}
     * @memberof SecretIdentifier
     */
    'project_id'?: number;
    /**
     * Type of the secret
     * @type {string}
     * @memberof SecretIdentifier
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TerraformProperties
 */
export interface TerraformProperties {
    /**
     * Terraform module properties
     * @type {object}
     * @memberof TerraformProperties
     */
    'module': object;
    /**
     * JSON schema for Terraform variables
     * @type {object}
     * @memberof TerraformProperties
     */
    'tfvars_json_schema': object;
}
/**
 * 
 * @export
 * @interface UpdateDeploymentInput
 */
export interface UpdateDeploymentInput {
    /**
     * ID of the module to deploy
     * @type {number}
     * @memberof UpdateDeploymentInput
     */
    'module_id': number;
    /**
     * 
     * @type {DeploymentInputs}
     * @memberof UpdateDeploymentInput
     */
    'inputs': DeploymentInputs;
}
/**
 * 
 * @export
 * @interface UpdateModuleInput
 */
export interface UpdateModuleInput {
    /**
     * Name of the module
     * @type {string}
     * @memberof UpdateModuleInput
     */
    'name'?: string;
    /**
     * 
     * @type {ModuleConfig}
     * @memberof UpdateModuleInput
     */
    'module_config'?: ModuleConfig;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationInput
 */
export interface UpdateOrganizationInput {
    /**
     * Name of the organization
     * @type {string}
     * @memberof UpdateOrganizationInput
     */
    'name'?: string;
    /**
     * Description of the organization
     * @type {string}
     * @memberof UpdateOrganizationInput
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProjectInput
 */
export interface UpdateProjectInput {
    /**
     * Name of the project
     * @type {string}
     * @memberof UpdateProjectInput
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateRepositoryInput
 */
export interface UpdateRepositoryInput {
    /**
     * Name of the repository
     * @type {string}
     * @memberof UpdateRepositoryInput
     */
    'name'?: string;
    /**
     * URL of the repository
     * @type {string}
     * @memberof UpdateRepositoryInput
     */
    'url'?: string;
    /**
     * 
     * @type {SecretIdentifier}
     * @memberof UpdateRepositoryInput
     */
    'secret'?: SecretIdentifier;
}
/**
 * 
 * @export
 * @interface VariableConfiguration
 */
export interface VariableConfiguration {
    /**
     * Available options for the variable (list of any type - string, number, boolean, object, etc.)
     * @type {Array<any>}
     * @memberof VariableConfiguration
     */
    'options'?: Array<any>;
    /**
     * Whether new options can be added beyond the predefined list. If true, users can add values not in the \'options\' list. If false or omitted, only values from the \'options\' list are allowed.
     * @type {boolean}
     * @memberof VariableConfiguration
     */
    'addable'?: boolean;
}

/**
 * DeploymentsApi - axios parameter creator
 * @export
 */
export const DeploymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of deployments, with optional filters for environment ID, project ID, and deployment ID
         * @summary Get all deployments
         * @param {number} projectId Project ID
         * @param {number} [id] Deployment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsGet: async (projectId: number, id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deploymentsGet', 'projectId', projectId)
            const localVarPath = `/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy an existing deployment by its ID
         * @summary Destroy a deployment
         * @param {number} id Deployment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsIdDelete', 'id', id)
            const localVarPath = `/deployments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific deployment by its ID and version
         * @summary Get deployment by ID and version
         * @param {number} id Deployment ID
         * @param {number} version Version number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsIdGet: async (id: number, version: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsIdGet', 'id', id)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('deploymentsIdGet', 'version', version)
            const localVarPath = `/deployments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of an existing deployment based on the provided input
         * @summary Update a deployment
         * @param {number} id Deployment ID
         * @param {UpdateDeploymentInput} updateDeploymentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsIdPatch: async (id: number, updateDeploymentInput: UpdateDeploymentInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deploymentsIdPatch', 'id', id)
            // verify required parameter 'updateDeploymentInput' is not null or undefined
            assertParamExists('deploymentsIdPatch', 'updateDeploymentInput', updateDeploymentInput)
            const localVarPath = `/deployments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeploymentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new module based on the provided input
         * @summary Deploy a module
         * @param {DeployModuleInput} deployModuleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsPost: async (deployModuleInput: DeployModuleInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deployModuleInput' is not null or undefined
            assertParamExists('deploymentsPost', 'deployModuleInput', deployModuleInput)
            const localVarPath = `/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployModuleInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentsApi - functional programming interface
 * @export
 */
export const DeploymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of deployments, with optional filters for environment ID, project ID, and deployment ID
         * @summary Get all deployments
         * @param {number} projectId Project ID
         * @param {number} [id] Deployment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsGet(projectId: number, id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Deployment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsGet(projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Destroy an existing deployment by its ID
         * @summary Destroy a deployment
         * @param {number} id Deployment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentsIdDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific deployment by its ID and version
         * @summary Get deployment by ID and version
         * @param {number} id Deployment ID
         * @param {number} version Version number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsIdGet(id: number, version: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deployment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsIdGet(id, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of an existing deployment based on the provided input
         * @summary Update a deployment
         * @param {number} id Deployment ID
         * @param {UpdateDeploymentInput} updateDeploymentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsIdPatch(id: number, updateDeploymentInput: UpdateDeploymentInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentsPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsIdPatch(id, updateDeploymentInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deploy a new module based on the provided input
         * @summary Deploy a module
         * @param {DeployModuleInput} deployModuleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsPost(deployModuleInput: DeployModuleInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentsPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsPost(deployModuleInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeploymentsApi - factory interface
 * @export
 */
export const DeploymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentsApiFp(configuration)
    return {
        /**
         * Retrieve a list of deployments, with optional filters for environment ID, project ID, and deployment ID
         * @summary Get all deployments
         * @param {number} projectId Project ID
         * @param {number} [id] Deployment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsGet(projectId: number, id?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Deployment>> {
            return localVarFp.deploymentsGet(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy an existing deployment by its ID
         * @summary Destroy a deployment
         * @param {number} id Deployment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentsIdDelete200Response> {
            return localVarFp.deploymentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific deployment by its ID and version
         * @summary Get deployment by ID and version
         * @param {number} id Deployment ID
         * @param {number} version Version number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsIdGet(id: number, version: number, options?: RawAxiosRequestConfig): AxiosPromise<Deployment> {
            return localVarFp.deploymentsIdGet(id, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of an existing deployment based on the provided input
         * @summary Update a deployment
         * @param {number} id Deployment ID
         * @param {UpdateDeploymentInput} updateDeploymentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsIdPatch(id: number, updateDeploymentInput: UpdateDeploymentInput, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentsPost201Response> {
            return localVarFp.deploymentsIdPatch(id, updateDeploymentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new module based on the provided input
         * @summary Deploy a module
         * @param {DeployModuleInput} deployModuleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsPost(deployModuleInput: DeployModuleInput, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentsPost201Response> {
            return localVarFp.deploymentsPost(deployModuleInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentsApi - interface
 * @export
 * @interface DeploymentsApi
 */
export interface DeploymentsApiInterface {
    /**
     * Retrieve a list of deployments, with optional filters for environment ID, project ID, and deployment ID
     * @summary Get all deployments
     * @param {number} projectId Project ID
     * @param {number} [id] Deployment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApiInterface
     */
    deploymentsGet(projectId: number, id?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Deployment>>;

    /**
     * Destroy an existing deployment by its ID
     * @summary Destroy a deployment
     * @param {number} id Deployment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApiInterface
     */
    deploymentsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentsIdDelete200Response>;

    /**
     * Retrieve a specific deployment by its ID and version
     * @summary Get deployment by ID and version
     * @param {number} id Deployment ID
     * @param {number} version Version number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApiInterface
     */
    deploymentsIdGet(id: number, version: number, options?: RawAxiosRequestConfig): AxiosPromise<Deployment>;

    /**
     * Update the details of an existing deployment based on the provided input
     * @summary Update a deployment
     * @param {number} id Deployment ID
     * @param {UpdateDeploymentInput} updateDeploymentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApiInterface
     */
    deploymentsIdPatch(id: number, updateDeploymentInput: UpdateDeploymentInput, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentsPost201Response>;

    /**
     * Deploy a new module based on the provided input
     * @summary Deploy a module
     * @param {DeployModuleInput} deployModuleInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApiInterface
     */
    deploymentsPost(deployModuleInput: DeployModuleInput, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentsPost201Response>;

}

/**
 * DeploymentsApi - object-oriented interface
 * @export
 * @class DeploymentsApi
 * @extends {BaseAPI}
 */
export class DeploymentsApi extends BaseAPI implements DeploymentsApiInterface {
    /**
     * Retrieve a list of deployments, with optional filters for environment ID, project ID, and deployment ID
     * @summary Get all deployments
     * @param {number} projectId Project ID
     * @param {number} [id] Deployment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsGet(projectId: number, id?: number, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsGet(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy an existing deployment by its ID
     * @summary Destroy a deployment
     * @param {number} id Deployment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific deployment by its ID and version
     * @summary Get deployment by ID and version
     * @param {number} id Deployment ID
     * @param {number} version Version number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsIdGet(id: number, version: number, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsIdGet(id, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of an existing deployment based on the provided input
     * @summary Update a deployment
     * @param {number} id Deployment ID
     * @param {UpdateDeploymentInput} updateDeploymentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsIdPatch(id: number, updateDeploymentInput: UpdateDeploymentInput, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsIdPatch(id, updateDeploymentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new module based on the provided input
     * @summary Deploy a module
     * @param {DeployModuleInput} deployModuleInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsPost(deployModuleInput: DeployModuleInput, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsPost(deployModuleInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModulesApi - axios parameter creator
 * @export
 */
export const ModulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all modules, optionally filtered by project_id and organization_id
         * @summary Get all modules
         * @param {number} [projectId] Project ID
         * @param {number} [organizationId] Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulesGet: async (projectId?: number, organizationId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/modules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organization_id'] = organizationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a module by its ID
         * @summary Delete a module
         * @param {number} id Module ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulesIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modulesIdDelete', 'id', id)
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single module by its ID
         * @summary Get module by ID
         * @param {number} id Module ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulesIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modulesIdGet', 'id', id)
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing module with the specified details
         * @summary Update a module
         * @param {number} id Module ID
         * @param {UpdateModuleInput} updateModuleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulesIdPut: async (id: number, updateModuleInput: UpdateModuleInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('modulesIdPut', 'id', id)
            // verify required parameter 'updateModuleInput' is not null or undefined
            assertParamExists('modulesIdPut', 'updateModuleInput', updateModuleInput)
            const localVarPath = `/modules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateModuleInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new module with specified details
         * @summary Create a new module
         * @param {CreateModuleInput} createModuleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulesPost: async (createModuleInput: CreateModuleInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createModuleInput' is not null or undefined
            assertParamExists('modulesPost', 'createModuleInput', createModuleInput)
            const localVarPath = `/modules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createModuleInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModulesApi - functional programming interface
 * @export
 */
export const ModulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all modules, optionally filtered by project_id and organization_id
         * @summary Get all modules
         * @param {number} [projectId] Project ID
         * @param {number} [organizationId] Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modulesGet(projectId?: number, organizationId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Module>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modulesGet(projectId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModulesApi.modulesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a module by its ID
         * @summary Delete a module
         * @param {number} id Module ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modulesIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modulesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModulesApi.modulesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single module by its ID
         * @summary Get module by ID
         * @param {number} id Module ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modulesIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Module>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modulesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModulesApi.modulesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing module with the specified details
         * @summary Update a module
         * @param {number} id Module ID
         * @param {UpdateModuleInput} updateModuleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modulesIdPut(id: number, updateModuleInput: UpdateModuleInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Module>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modulesIdPut(id, updateModuleInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModulesApi.modulesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new module with specified details
         * @summary Create a new module
         * @param {CreateModuleInput} createModuleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modulesPost(createModuleInput: CreateModuleInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Module>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modulesPost(createModuleInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModulesApi.modulesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModulesApi - factory interface
 * @export
 */
export const ModulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModulesApiFp(configuration)
    return {
        /**
         * Retrieve a list of all modules, optionally filtered by project_id and organization_id
         * @summary Get all modules
         * @param {number} [projectId] Project ID
         * @param {number} [organizationId] Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulesGet(projectId?: number, organizationId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Module>> {
            return localVarFp.modulesGet(projectId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a module by its ID
         * @summary Delete a module
         * @param {number} id Module ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulesIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.modulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single module by its ID
         * @summary Get module by ID
         * @param {number} id Module ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulesIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Module> {
            return localVarFp.modulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing module with the specified details
         * @summary Update a module
         * @param {number} id Module ID
         * @param {UpdateModuleInput} updateModuleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulesIdPut(id: number, updateModuleInput: UpdateModuleInput, options?: RawAxiosRequestConfig): AxiosPromise<Module> {
            return localVarFp.modulesIdPut(id, updateModuleInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new module with specified details
         * @summary Create a new module
         * @param {CreateModuleInput} createModuleInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modulesPost(createModuleInput: CreateModuleInput, options?: RawAxiosRequestConfig): AxiosPromise<Module> {
            return localVarFp.modulesPost(createModuleInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModulesApi - interface
 * @export
 * @interface ModulesApi
 */
export interface ModulesApiInterface {
    /**
     * Retrieve a list of all modules, optionally filtered by project_id and organization_id
     * @summary Get all modules
     * @param {number} [projectId] Project ID
     * @param {number} [organizationId] Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApiInterface
     */
    modulesGet(projectId?: number, organizationId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Module>>;

    /**
     * Delete a module by its ID
     * @summary Delete a module
     * @param {number} id Module ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApiInterface
     */
    modulesIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a single module by its ID
     * @summary Get module by ID
     * @param {number} id Module ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApiInterface
     */
    modulesIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Module>;

    /**
     * Update an existing module with the specified details
     * @summary Update a module
     * @param {number} id Module ID
     * @param {UpdateModuleInput} updateModuleInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApiInterface
     */
    modulesIdPut(id: number, updateModuleInput: UpdateModuleInput, options?: RawAxiosRequestConfig): AxiosPromise<Module>;

    /**
     * Create a new module with specified details
     * @summary Create a new module
     * @param {CreateModuleInput} createModuleInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApiInterface
     */
    modulesPost(createModuleInput: CreateModuleInput, options?: RawAxiosRequestConfig): AxiosPromise<Module>;

}

/**
 * ModulesApi - object-oriented interface
 * @export
 * @class ModulesApi
 * @extends {BaseAPI}
 */
export class ModulesApi extends BaseAPI implements ModulesApiInterface {
    /**
     * Retrieve a list of all modules, optionally filtered by project_id and organization_id
     * @summary Get all modules
     * @param {number} [projectId] Project ID
     * @param {number} [organizationId] Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApi
     */
    public modulesGet(projectId?: number, organizationId?: number, options?: RawAxiosRequestConfig) {
        return ModulesApiFp(this.configuration).modulesGet(projectId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a module by its ID
     * @summary Delete a module
     * @param {number} id Module ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApi
     */
    public modulesIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return ModulesApiFp(this.configuration).modulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single module by its ID
     * @summary Get module by ID
     * @param {number} id Module ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApi
     */
    public modulesIdGet(id: number, options?: RawAxiosRequestConfig) {
        return ModulesApiFp(this.configuration).modulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing module with the specified details
     * @summary Update a module
     * @param {number} id Module ID
     * @param {UpdateModuleInput} updateModuleInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApi
     */
    public modulesIdPut(id: number, updateModuleInput: UpdateModuleInput, options?: RawAxiosRequestConfig) {
        return ModulesApiFp(this.configuration).modulesIdPut(id, updateModuleInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new module with specified details
     * @summary Create a new module
     * @param {CreateModuleInput} createModuleInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApi
     */
    public modulesPost(createModuleInput: CreateModuleInput, options?: RawAxiosRequestConfig) {
        return ModulesApiFp(this.configuration).modulesPost(createModuleInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all organizations
         * @summary Get all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an organization by its ID
         * @summary Delete an organization
         * @param {number} id Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgsIdDelete', 'id', id)
            const localVarPath = `/orgs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an organization by its ID
         * @summary Get an organization by ID
         * @param {number} id Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgsIdGet', 'id', id)
            const localVarPath = `/orgs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an organization\'s details by ID
         * @summary Update an organization
         * @param {number} id Organization ID
         * @param {UpdateOrganizationInput} updateOrganizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsIdPut: async (id: number, updateOrganizationInput: UpdateOrganizationInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orgsIdPut', 'id', id)
            // verify required parameter 'updateOrganizationInput' is not null or undefined
            assertParamExists('orgsIdPut', 'updateOrganizationInput', updateOrganizationInput)
            const localVarPath = `/orgs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new organization with name and description
         * @summary Create a new organization
         * @param {CreateOrganizationInput} createOrganizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsPost: async (createOrganizationInput: CreateOrganizationInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationInput' is not null or undefined
            assertParamExists('orgsPost', 'createOrganizationInput', createOrganizationInput)
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all organizations
         * @summary Get all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.orgsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an organization by its ID
         * @summary Delete an organization
         * @param {number} id Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.orgsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an organization by its ID
         * @summary Get an organization by ID
         * @param {number} id Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.orgsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an organization\'s details by ID
         * @summary Update an organization
         * @param {number} id Organization ID
         * @param {UpdateOrganizationInput} updateOrganizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsIdPut(id: number, updateOrganizationInput: UpdateOrganizationInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsIdPut(id, updateOrganizationInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.orgsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new organization with name and description
         * @summary Create a new organization
         * @param {CreateOrganizationInput} createOrganizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsPost(createOrganizationInput: CreateOrganizationInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsPost(createOrganizationInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.orgsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * Retrieve a list of all organizations
         * @summary Get all organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Organization>> {
            return localVarFp.orgsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an organization by its ID
         * @summary Delete an organization
         * @param {number} id Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an organization by its ID
         * @summary Get an organization by ID
         * @param {number} id Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.orgsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an organization\'s details by ID
         * @summary Update an organization
         * @param {number} id Organization ID
         * @param {UpdateOrganizationInput} updateOrganizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsIdPut(id: number, updateOrganizationInput: UpdateOrganizationInput, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.orgsIdPut(id, updateOrganizationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new organization with name and description
         * @summary Create a new organization
         * @param {CreateOrganizationInput} createOrganizationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsPost(createOrganizationInput: CreateOrganizationInput, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.orgsPost(createOrganizationInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - interface
 * @export
 * @interface OrganizationsApi
 */
export interface OrganizationsApiInterface {
    /**
     * Retrieve a list of all organizations
     * @summary Get all organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    orgsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Organization>>;

    /**
     * Remove an organization by its ID
     * @summary Delete an organization
     * @param {number} id Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    orgsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve an organization by its ID
     * @summary Get an organization by ID
     * @param {number} id Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    orgsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Organization>;

    /**
     * Update an organization\'s details by ID
     * @summary Update an organization
     * @param {number} id Organization ID
     * @param {UpdateOrganizationInput} updateOrganizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    orgsIdPut(id: number, updateOrganizationInput: UpdateOrganizationInput, options?: RawAxiosRequestConfig): AxiosPromise<Organization>;

    /**
     * Add a new organization with name and description
     * @summary Create a new organization
     * @param {CreateOrganizationInput} createOrganizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    orgsPost(createOrganizationInput: CreateOrganizationInput, options?: RawAxiosRequestConfig): AxiosPromise<Organization>;

}

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI implements OrganizationsApiInterface {
    /**
     * Retrieve a list of all organizations
     * @summary Get all organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsGet(options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).orgsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an organization by its ID
     * @summary Delete an organization
     * @param {number} id Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).orgsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an organization by its ID
     * @summary Get an organization by ID
     * @param {number} id Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).orgsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an organization\'s details by ID
     * @summary Update an organization
     * @param {number} id Organization ID
     * @param {UpdateOrganizationInput} updateOrganizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsIdPut(id: number, updateOrganizationInput: UpdateOrganizationInput, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).orgsIdPut(id, updateOrganizationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new organization with name and description
     * @summary Create a new organization
     * @param {CreateOrganizationInput} createOrganizationInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public orgsPost(createOrganizationInput: CreateOrganizationInput, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).orgsPost(createOrganizationInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all projects associated with a specific organization
         * @summary Get projects by organization ID
         * @param {number} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdProjectsGet: async (organizationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdProjectsGet', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organizationId}/projects`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project by its ID
         * @summary Delete a project
         * @param {number} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsIdDelete', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single project by its ID
         * @summary Get project by ID
         * @param {number} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsIdGet', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of an existing project by ID
         * @summary Update an existing project
         * @param {number} id Project ID
         * @param {UpdateProjectInput} updateProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdPut: async (id: number, updateProjectInput: UpdateProjectInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsIdPut', 'id', id)
            // verify required parameter 'updateProjectInput' is not null or undefined
            assertParamExists('projectsIdPut', 'updateProjectInput', updateProjectInput)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new project with specified details
         * @summary Create a new project
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPost: async (createProjectInput: CreateProjectInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectInput' is not null or undefined
            assertParamExists('projectsPost', 'createProjectInput', createProjectInput)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all projects associated with a specific organization
         * @summary Get projects by organization ID
         * @param {number} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdProjectsGet(organizationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdProjectsGet(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.organizationsOrganizationIdProjectsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a project by its ID
         * @summary Delete a project
         * @param {number} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single project by its ID
         * @summary Get project by ID
         * @param {number} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of an existing project by ID
         * @summary Update an existing project
         * @param {number} id Project ID
         * @param {UpdateProjectInput} updateProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsIdPut(id: number, updateProjectInput: UpdateProjectInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsIdPut(id, updateProjectInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new project with specified details
         * @summary Create a new project
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsPost(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsPost(createProjectInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Retrieve all projects associated with a specific organization
         * @summary Get projects by organization ID
         * @param {number} organizationId Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdProjectsGet(organizationId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Project>> {
            return localVarFp.organizationsOrganizationIdProjectsGet(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a project by its ID
         * @summary Delete a project
         * @param {number} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single project by its ID
         * @summary Get project by ID
         * @param {number} id Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.projectsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of an existing project by ID
         * @summary Update an existing project
         * @param {number} id Project ID
         * @param {UpdateProjectInput} updateProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsIdPut(id: number, updateProjectInput: UpdateProjectInput, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.projectsIdPut(id, updateProjectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new project with specified details
         * @summary Create a new project
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPost(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.projectsPost(createProjectInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - interface
 * @export
 * @interface ProjectsApi
 */
export interface ProjectsApiInterface {
    /**
     * Retrieve all projects associated with a specific organization
     * @summary Get projects by organization ID
     * @param {number} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    organizationsOrganizationIdProjectsGet(organizationId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Project>>;

    /**
     * Delete a project by its ID
     * @summary Delete a project
     * @param {number} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a single project by its ID
     * @summary Get project by ID
     * @param {number} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Project>;

    /**
     * Update the details of an existing project by ID
     * @summary Update an existing project
     * @param {number} id Project ID
     * @param {UpdateProjectInput} updateProjectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsIdPut(id: number, updateProjectInput: UpdateProjectInput, options?: RawAxiosRequestConfig): AxiosPromise<Project>;

    /**
     * Create a new project with specified details
     * @summary Create a new project
     * @param {CreateProjectInput} createProjectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsPost(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig): AxiosPromise<Project>;

}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI implements ProjectsApiInterface {
    /**
     * Retrieve all projects associated with a specific organization
     * @summary Get projects by organization ID
     * @param {number} organizationId Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public organizationsOrganizationIdProjectsGet(organizationId: number, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).organizationsOrganizationIdProjectsGet(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a project by its ID
     * @summary Delete a project
     * @param {number} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single project by its ID
     * @summary Get project by ID
     * @param {number} id Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of an existing project by ID
     * @summary Update an existing project
     * @param {number} id Project ID
     * @param {UpdateProjectInput} updateProjectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsIdPut(id: number, updateProjectInput: UpdateProjectInput, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsIdPut(id, updateProjectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new project with specified details
     * @summary Create a new project
     * @param {CreateProjectInput} createProjectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsPost(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsPost(createProjectInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesApi - axios parameter creator
 * @export
 */
export const RepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of repositories. Optionally filter by project_id or organization_id query parameters.
         * @summary Get repositories
         * @param {number} [projectId] Project ID
         * @param {number} [organizationId] Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesGet: async (projectId?: number, organizationId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organization_id'] = organizationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a repository by its ID.
         * @summary Delete a repository
         * @param {number} id Repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repositoriesIdDelete', 'id', id)
            const localVarPath = `/repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single repository by its ID.
         * @summary Get repository by ID
         * @param {number} id Repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repositoriesIdGet', 'id', id)
            const localVarPath = `/repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing repository with the specified details
         * @summary Update a repository
         * @param {number} id Repository ID
         * @param {UpdateRepositoryInput} updateRepositoryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesIdPut: async (id: number, updateRepositoryInput: UpdateRepositoryInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repositoriesIdPut', 'id', id)
            // verify required parameter 'updateRepositoryInput' is not null or undefined
            assertParamExists('repositoriesIdPut', 'updateRepositoryInput', updateRepositoryInput)
            const localVarPath = `/repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRepositoryInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new repository with the specified details. The request body should include owner, repo, project_id, and organization_id.
         * @summary Create a new repository
         * @param {CreateRepositoryInput} createRepositoryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesPost: async (createRepositoryInput: CreateRepositoryInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRepositoryInput' is not null or undefined
            assertParamExists('repositoriesPost', 'createRepositoryInput', createRepositoryInput)
            const localVarPath = `/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRepositoryInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesApi - functional programming interface
 * @export
 */
export const RepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of repositories. Optionally filter by project_id or organization_id query parameters.
         * @summary Get repositories
         * @param {number} [projectId] Project ID
         * @param {number} [organizationId] Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesGet(projectId?: number, organizationId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesGet(projectId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a repository by its ID.
         * @summary Delete a repository
         * @param {number} id Repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single repository by its ID.
         * @summary Get repository by ID
         * @param {number} id Repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing repository with the specified details
         * @summary Update a repository
         * @param {number} id Repository ID
         * @param {UpdateRepositoryInput} updateRepositoryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesIdPut(id: number, updateRepositoryInput: UpdateRepositoryInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesIdPut(id, updateRepositoryInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new repository with the specified details. The request body should include owner, repo, project_id, and organization_id.
         * @summary Create a new repository
         * @param {CreateRepositoryInput} createRepositoryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositoriesPost(createRepositoryInput: CreateRepositoryInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositoriesPost(createRepositoryInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.repositoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RepositoriesApi - factory interface
 * @export
 */
export const RepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesApiFp(configuration)
    return {
        /**
         * Retrieve a list of repositories. Optionally filter by project_id or organization_id query parameters.
         * @summary Get repositories
         * @param {number} [projectId] Project ID
         * @param {number} [organizationId] Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesGet(projectId?: number, organizationId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Repository>> {
            return localVarFp.repositoriesGet(projectId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a repository by its ID.
         * @summary Delete a repository
         * @param {number} id Repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.repositoriesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single repository by its ID.
         * @summary Get repository by ID
         * @param {number} id Repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryResponse> {
            return localVarFp.repositoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing repository with the specified details
         * @summary Update a repository
         * @param {number} id Repository ID
         * @param {UpdateRepositoryInput} updateRepositoryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesIdPut(id: number, updateRepositoryInput: UpdateRepositoryInput, options?: RawAxiosRequestConfig): AxiosPromise<Repository> {
            return localVarFp.repositoriesIdPut(id, updateRepositoryInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new repository with the specified details. The request body should include owner, repo, project_id, and organization_id.
         * @summary Create a new repository
         * @param {CreateRepositoryInput} createRepositoryInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositoriesPost(createRepositoryInput: CreateRepositoryInput, options?: RawAxiosRequestConfig): AxiosPromise<Repository> {
            return localVarFp.repositoriesPost(createRepositoryInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesApi - interface
 * @export
 * @interface RepositoriesApi
 */
export interface RepositoriesApiInterface {
    /**
     * Retrieve a list of repositories. Optionally filter by project_id or organization_id query parameters.
     * @summary Get repositories
     * @param {number} [projectId] Project ID
     * @param {number} [organizationId] Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    repositoriesGet(projectId?: number, organizationId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * Delete a repository by its ID.
     * @summary Delete a repository
     * @param {number} id Repository ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    repositoriesIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a single repository by its ID.
     * @summary Get repository by ID
     * @param {number} id Repository ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    repositoriesIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryResponse>;

    /**
     * Update an existing repository with the specified details
     * @summary Update a repository
     * @param {number} id Repository ID
     * @param {UpdateRepositoryInput} updateRepositoryInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    repositoriesIdPut(id: number, updateRepositoryInput: UpdateRepositoryInput, options?: RawAxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * Create a new repository with the specified details. The request body should include owner, repo, project_id, and organization_id.
     * @summary Create a new repository
     * @param {CreateRepositoryInput} createRepositoryInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApiInterface
     */
    repositoriesPost(createRepositoryInput: CreateRepositoryInput, options?: RawAxiosRequestConfig): AxiosPromise<Repository>;

}

/**
 * RepositoriesApi - object-oriented interface
 * @export
 * @class RepositoriesApi
 * @extends {BaseAPI}
 */
export class RepositoriesApi extends BaseAPI implements RepositoriesApiInterface {
    /**
     * Retrieve a list of repositories. Optionally filter by project_id or organization_id query parameters.
     * @summary Get repositories
     * @param {number} [projectId] Project ID
     * @param {number} [organizationId] Organization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public repositoriesGet(projectId?: number, organizationId?: number, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesGet(projectId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a repository by its ID.
     * @summary Delete a repository
     * @param {number} id Repository ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public repositoriesIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single repository by its ID.
     * @summary Get repository by ID
     * @param {number} id Repository ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public repositoriesIdGet(id: number, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing repository with the specified details
     * @summary Update a repository
     * @param {number} id Repository ID
     * @param {UpdateRepositoryInput} updateRepositoryInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public repositoriesIdPut(id: number, updateRepositoryInput: UpdateRepositoryInput, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesIdPut(id, updateRepositoryInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new repository with the specified details. The request body should include owner, repo, project_id, and organization_id.
     * @summary Create a new repository
     * @param {CreateRepositoryInput} createRepositoryInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public repositoriesPost(createRepositoryInput: CreateRepositoryInput, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).repositoriesPost(createRepositoryInput, options).then((request) => request(this.axios, this.basePath));
    }
}




/* tslint:disable */
/* eslint-disable */
/**
 * Runner Microservice API
 * API for managing Runs and Terraform States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface DispatchRunRequest
 */
export interface DispatchRunRequest {
    /**
     * 
     * @type {number}
     * @memberof DispatchRunRequest
     */
    'deploymentId': number;
    /**
     * 
     * @type {RunProperties}
     * @memberof DispatchRunRequest
     */
    'runProperties': RunProperties;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * 
     * @type {number}
     * @memberof Run
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Run
     */
    'deployment_id'?: number;
    /**
     * 
     * @type {RunStatus}
     * @memberof Run
     */
    'status'?: RunStatus;
    /**
     * 
     * @type {StatusDetails}
     * @memberof Run
     */
    'status_details'?: StatusDetails;
    /**
     * 
     * @type {RunProperties}
     * @memberof Run
     */
    'properties'?: RunProperties;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    'timestamp'?: string;
}


/**
 * 
 * @export
 * @interface RunProperties
 */
export interface RunProperties {
    /**
     * 
     * @type {string}
     * @memberof RunProperties
     */
    'run_by': string;
    /**
     * 
     * @type {number}
     * @memberof RunProperties
     */
    'deployment_version': number;
    /**
     * 
     * @type {string}
     * @memberof RunProperties
     */
    'terraform_command': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RunStatus = {
    Pending: 'pending',
    Claimed: 'claimed',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type RunStatus = typeof RunStatus[keyof typeof RunStatus];


/**
 * 
 * @export
 * @interface StatusDetails
 */
export interface StatusDetails {
    /**
     * 
     * @type {string}
     * @memberof StatusDetails
     */
    'error_message'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StatusDetails
     */
    'waiting_for_current_run'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof StatusDetails
     */
    'approval_needed_from'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface TerraformState
 */
export interface TerraformState {
    /**
     * 
     * @type {number}
     * @memberof TerraformState
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TerraformState
     */
    'deployment_id': number;
    /**
     * 
     * @type {number}
     * @memberof TerraformState
     */
    'deployment_version': number;
    /**
     * 
     * @type {string}
     * @memberof TerraformState
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface TfStateExists200Response
 */
export interface TfStateExists200Response {
    /**
     * 
     * @type {boolean}
     * @memberof TfStateExists200Response
     */
    'exists'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateRunStatusRequest
 */
export interface UpdateRunStatusRequest {
    /**
     * 
     * @type {RunStatus}
     * @memberof UpdateRunStatusRequest
     */
    'status': RunStatus;
    /**
     * 
     * @type {StatusDetails}
     * @memberof UpdateRunStatusRequest
     */
    'details'?: StatusDetails;
}



/**
 * RunServiceApi - axios parameter creator
 * @export
 */
export const RunServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Destroy a run by its ID
         * @param {number} runId ID of the run to destroy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRun: async (runId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('destroyRun', 'runId', runId)
            const localVarPath = `/runs/{runId}`
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dispatch a new run
         * @param {DispatchRunRequest} dispatchRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchRun: async (dispatchRunRequest: DispatchRunRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dispatchRunRequest' is not null or undefined
            assertParamExists('dispatchRun', 'dispatchRunRequest', dispatchRunRequest)
            const localVarPath = `/runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dispatchRunRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a run by its ID
         * @param {number} runId ID of the run to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunById: async (runId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunById', 'runId', runId)
            const localVarPath = `/runs/{runId}`
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get logs for a run
         * @param {number} runId ID of the run to retrieve logs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs: async (runId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunLogs', 'runId', runId)
            const localVarPath = `/runs/{runId}/logs`
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all runs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuns: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get runs by status
         * @param {RunStatus} status The status of the runs to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunsByStatus: async (status: RunStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('getRunsByStatus', 'status', status)
            const localVarPath = `/runs/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the status of a run
         * @param {number} runId ID of the run to update.
         * @param {UpdateRunStatusRequest} updateRunStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunStatus: async (runId: number, updateRunStatusRequest: UpdateRunStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('updateRunStatus', 'runId', runId)
            // verify required parameter 'updateRunStatusRequest' is not null or undefined
            assertParamExists('updateRunStatus', 'updateRunStatusRequest', updateRunStatusRequest)
            const localVarPath = `/runs/{runId}/status`
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRunStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunServiceApi - functional programming interface
 * @export
 */
export const RunServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Destroy a run by its ID
         * @param {number} runId ID of the run to destroy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyRun(runId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyRun(runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunServiceApi.destroyRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dispatch a new run
         * @param {DispatchRunRequest} dispatchRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dispatchRun(dispatchRunRequest: DispatchRunRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dispatchRun(dispatchRunRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunServiceApi.dispatchRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a run by its ID
         * @param {number} runId ID of the run to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunById(runId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunById(runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunServiceApi.getRunById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get logs for a run
         * @param {number} runId ID of the run to retrieve logs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunLogs(runId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunLogs(runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunServiceApi.getRunLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all runs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuns(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Run>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuns(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunServiceApi.getRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get runs by status
         * @param {RunStatus} status The status of the runs to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunsByStatus(status: RunStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Run>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunsByStatus(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunServiceApi.getRunsByStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the status of a run
         * @param {number} runId ID of the run to update.
         * @param {UpdateRunStatusRequest} updateRunStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunStatus(runId: number, updateRunStatusRequest: UpdateRunStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunStatus(runId, updateRunStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunServiceApi.updateRunStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunServiceApi - factory interface
 * @export
 */
export const RunServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Destroy a run by its ID
         * @param {number} runId ID of the run to destroy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRun(runId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.destroyRun(runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dispatch a new run
         * @param {DispatchRunRequest} dispatchRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dispatchRun(dispatchRunRequest: DispatchRunRequest, options?: RawAxiosRequestConfig): AxiosPromise<Run> {
            return localVarFp.dispatchRun(dispatchRunRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a run by its ID
         * @param {number} runId ID of the run to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunById(runId: number, options?: RawAxiosRequestConfig): AxiosPromise<Run> {
            return localVarFp.getRunById(runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get logs for a run
         * @param {number} runId ID of the run to retrieve logs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs(runId: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getRunLogs(runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all runs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuns(options?: RawAxiosRequestConfig): AxiosPromise<Array<Run>> {
            return localVarFp.getRuns(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get runs by status
         * @param {RunStatus} status The status of the runs to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunsByStatus(status: RunStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<Run>> {
            return localVarFp.getRunsByStatus(status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the status of a run
         * @param {number} runId ID of the run to update.
         * @param {UpdateRunStatusRequest} updateRunStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunStatus(runId: number, updateRunStatusRequest: UpdateRunStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRunStatus(runId, updateRunStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunServiceApi - interface
 * @export
 * @interface RunServiceApi
 */
export interface RunServiceApiInterface {
    /**
     * 
     * @summary Destroy a run by its ID
     * @param {number} runId ID of the run to destroy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApiInterface
     */
    destroyRun(runId: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Dispatch a new run
     * @param {DispatchRunRequest} dispatchRunRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApiInterface
     */
    dispatchRun(dispatchRunRequest: DispatchRunRequest, options?: RawAxiosRequestConfig): AxiosPromise<Run>;

    /**
     * 
     * @summary Get a run by its ID
     * @param {number} runId ID of the run to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApiInterface
     */
    getRunById(runId: number, options?: RawAxiosRequestConfig): AxiosPromise<Run>;

    /**
     * 
     * @summary Get logs for a run
     * @param {number} runId ID of the run to retrieve logs for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApiInterface
     */
    getRunLogs(runId: number, options?: RawAxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary List all runs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApiInterface
     */
    getRuns(options?: RawAxiosRequestConfig): AxiosPromise<Array<Run>>;

    /**
     * 
     * @summary Get runs by status
     * @param {RunStatus} status The status of the runs to filter by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApiInterface
     */
    getRunsByStatus(status: RunStatus, options?: RawAxiosRequestConfig): AxiosPromise<Array<Run>>;

    /**
     * 
     * @summary Update the status of a run
     * @param {number} runId ID of the run to update.
     * @param {UpdateRunStatusRequest} updateRunStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApiInterface
     */
    updateRunStatus(runId: number, updateRunStatusRequest: UpdateRunStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * RunServiceApi - object-oriented interface
 * @export
 * @class RunServiceApi
 * @extends {BaseAPI}
 */
export class RunServiceApi extends BaseAPI implements RunServiceApiInterface {
    /**
     * 
     * @summary Destroy a run by its ID
     * @param {number} runId ID of the run to destroy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public destroyRun(runId: number, options?: RawAxiosRequestConfig) {
        return RunServiceApiFp(this.configuration).destroyRun(runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dispatch a new run
     * @param {DispatchRunRequest} dispatchRunRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public dispatchRun(dispatchRunRequest: DispatchRunRequest, options?: RawAxiosRequestConfig) {
        return RunServiceApiFp(this.configuration).dispatchRun(dispatchRunRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a run by its ID
     * @param {number} runId ID of the run to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public getRunById(runId: number, options?: RawAxiosRequestConfig) {
        return RunServiceApiFp(this.configuration).getRunById(runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get logs for a run
     * @param {number} runId ID of the run to retrieve logs for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public getRunLogs(runId: number, options?: RawAxiosRequestConfig) {
        return RunServiceApiFp(this.configuration).getRunLogs(runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all runs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public getRuns(options?: RawAxiosRequestConfig) {
        return RunServiceApiFp(this.configuration).getRuns(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get runs by status
     * @param {RunStatus} status The status of the runs to filter by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public getRunsByStatus(status: RunStatus, options?: RawAxiosRequestConfig) {
        return RunServiceApiFp(this.configuration).getRunsByStatus(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the status of a run
     * @param {number} runId ID of the run to update.
     * @param {UpdateRunStatusRequest} updateRunStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public updateRunStatus(runId: number, updateRunStatusRequest: UpdateRunStatusRequest, options?: RawAxiosRequestConfig) {
        return RunServiceApiFp(this.configuration).updateRunStatus(runId, updateRunStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TfStateServiceApi - axios parameter creator
 * @export
 */
export const TfStateServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Terraform state by deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTfStateByDeploymentId: async (deploymentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentId' is not null or undefined
            assertParamExists('deleteTfStateByDeploymentId', 'deploymentId', deploymentId)
            const localVarPath = `/tfstate/{deploymentId}`
                .replace(`{${"deploymentId"}}`, encodeURIComponent(String(deploymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Terraform state by deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTfStateByDeploymentId: async (deploymentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentId' is not null or undefined
            assertParamExists('getTfStateByDeploymentId', 'deploymentId', deploymentId)
            const localVarPath = `/tfstate/{deploymentId}`
                .replace(`{${"deploymentId"}}`, encodeURIComponent(String(deploymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Store or update Terraform state by deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {string} body The Terraform state string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTfState: async (deploymentId: number, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentId' is not null or undefined
            assertParamExists('storeTfState', 'deploymentId', deploymentId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('storeTfState', 'body', body)
            const localVarPath = `/tfstate/{deploymentId}`
                .replace(`{${"deploymentId"}}`, encodeURIComponent(String(deploymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if Terraform state exists for a deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfStateExists: async (deploymentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentId' is not null or undefined
            assertParamExists('tfStateExists', 'deploymentId', deploymentId)
            const localVarPath = `/tfstate/{deploymentId}/exists`
                .replace(`{${"deploymentId"}}`, encodeURIComponent(String(deploymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TfStateServiceApi - functional programming interface
 * @export
 */
export const TfStateServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TfStateServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Terraform state by deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTfStateByDeploymentId(deploymentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTfStateByDeploymentId(deploymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TfStateServiceApi.deleteTfStateByDeploymentId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Terraform state by deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTfStateByDeploymentId(deploymentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerraformState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTfStateByDeploymentId(deploymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TfStateServiceApi.getTfStateByDeploymentId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Store or update Terraform state by deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {string} body The Terraform state string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeTfState(deploymentId: number, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeTfState(deploymentId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TfStateServiceApi.storeTfState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if Terraform state exists for a deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tfStateExists(deploymentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TfStateExists200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tfStateExists(deploymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TfStateServiceApi.tfStateExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TfStateServiceApi - factory interface
 * @export
 */
export const TfStateServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TfStateServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Terraform state by deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTfStateByDeploymentId(deploymentId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTfStateByDeploymentId(deploymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Terraform state by deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTfStateByDeploymentId(deploymentId: number, options?: RawAxiosRequestConfig): AxiosPromise<TerraformState> {
            return localVarFp.getTfStateByDeploymentId(deploymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Store or update Terraform state by deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {string} body The Terraform state string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTfState(deploymentId: number, body: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.storeTfState(deploymentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if Terraform state exists for a deployment ID
         * @param {number} deploymentId ID of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tfStateExists(deploymentId: number, options?: RawAxiosRequestConfig): AxiosPromise<TfStateExists200Response> {
            return localVarFp.tfStateExists(deploymentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TfStateServiceApi - interface
 * @export
 * @interface TfStateServiceApi
 */
export interface TfStateServiceApiInterface {
    /**
     * 
     * @summary Delete Terraform state by deployment ID
     * @param {number} deploymentId ID of the deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TfStateServiceApiInterface
     */
    deleteTfStateByDeploymentId(deploymentId: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get Terraform state by deployment ID
     * @param {number} deploymentId ID of the deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TfStateServiceApiInterface
     */
    getTfStateByDeploymentId(deploymentId: number, options?: RawAxiosRequestConfig): AxiosPromise<TerraformState>;

    /**
     * 
     * @summary Store or update Terraform state by deployment ID
     * @param {number} deploymentId ID of the deployment.
     * @param {string} body The Terraform state string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TfStateServiceApiInterface
     */
    storeTfState(deploymentId: number, body: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Check if Terraform state exists for a deployment ID
     * @param {number} deploymentId ID of the deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TfStateServiceApiInterface
     */
    tfStateExists(deploymentId: number, options?: RawAxiosRequestConfig): AxiosPromise<TfStateExists200Response>;

}

/**
 * TfStateServiceApi - object-oriented interface
 * @export
 * @class TfStateServiceApi
 * @extends {BaseAPI}
 */
export class TfStateServiceApi extends BaseAPI implements TfStateServiceApiInterface {
    /**
     * 
     * @summary Delete Terraform state by deployment ID
     * @param {number} deploymentId ID of the deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TfStateServiceApi
     */
    public deleteTfStateByDeploymentId(deploymentId: number, options?: RawAxiosRequestConfig) {
        return TfStateServiceApiFp(this.configuration).deleteTfStateByDeploymentId(deploymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Terraform state by deployment ID
     * @param {number} deploymentId ID of the deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TfStateServiceApi
     */
    public getTfStateByDeploymentId(deploymentId: number, options?: RawAxiosRequestConfig) {
        return TfStateServiceApiFp(this.configuration).getTfStateByDeploymentId(deploymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Store or update Terraform state by deployment ID
     * @param {number} deploymentId ID of the deployment.
     * @param {string} body The Terraform state string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TfStateServiceApi
     */
    public storeTfState(deploymentId: number, body: string, options?: RawAxiosRequestConfig) {
        return TfStateServiceApiFp(this.configuration).storeTfState(deploymentId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if Terraform state exists for a deployment ID
     * @param {number} deploymentId ID of the deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TfStateServiceApi
     */
    public tfStateExists(deploymentId: number, options?: RawAxiosRequestConfig) {
        return TfStateServiceApiFp(this.configuration).tfStateExists(deploymentId, options).then((request) => request(this.axios, this.basePath));
    }
}



